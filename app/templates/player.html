<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Metadata and stylesheets -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>{{ show.name }} - {{ episode.name }}</title>
    <!-- Video.js and HLS.js -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <link href="https://vjs.zencdn.net/7.10.2/video-js.min.css" rel="stylesheet">
    <script src="https://vjs.zencdn.net/7.10.2/video.min.js"></script>
    <!-- Custom styles -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.7.2/font/bootstrap-icons.css">
    

    <style>
        /* Existing styles... */

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000; /* Ensure background is black */
        }
        #video-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .video-js {
            width: 100% !important;
            height: 100% !important;
        }
      
        .vjs-controls-hidden .vjs-control-bar {
            display: none !important;
        }
        .vjs-control-bar {
            padding-top: 15px;
            padding-bottom: 15px;
            background-color: rgba(26, 26, 26, 0.7) !important;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            height: 60px !important;
        }
       
        .video-js .vjs-play-progress {
            background-color: #00a0ff;
        }
        .video-js .vjs-progress-holder {
            background-color: rgba(255, 255, 255, 0.3);
        }
        .show-title-player {
            font-size: 24px;
            margin: 0 0 5px 0;
            margin-top: 20px;
            color: white;
            font-weight: bold;
        }
        .episode-title-player {
            font-size: 18px;
            margin-top: -12px;
            color: #ccc;
        }
        
        .video-js .vjs-big-play-button {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: none;
            background-color: rgba(43, 51, 63, 0.7);
            width: 100px;
            height: 100px;
            border-radius: 50%;
        }

        .video-js .vjs-big-play-button .vjs-icon-placeholder:before {
            font-size: 60px;
            line-height: 100px;
            width: 100px;
            height: 100px;
        }

        #ad-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10000; /* Increased z-index */
            display: none; /* Hidden by default */
        }

        .adblock-notification {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            font-size: 12px;
            text-align: center;
            z-index: 10005;
            display: none;
            transition: opacity 0.5s ease-in-out;
            border-radius: 20px;
            max-width: 80%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .adblock-notification button {
            background: none;
            border: none;
            color: white;
            font-size: 16px;
            cursor: pointer;
            padding: 0 5px;
            margin-left: 10px;
            vertical-align: middle;
        }



        #adblock-prompt button:hover {
            background-color: #008ecc;
        }

        .video-js.vjs-fullscreen #ad-container {
            display: block; /* Show ad container in fullscreen */
            z-index: 10000; /* Ensure it's above fullscreen elements */
        }

        #back-button {
            background-color: rgba(0, 0, 0, 0.6);
            color: #fff;
            border: none;
            padding: 10px 15px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
            display: flex;
            align-items: center;
            transition: background-color 0.3s ease;
            z-index: 10002; /* Ensure it's above other elements */
            pointer-events: auto; /* Ensure it can receive pointer events */
        }
    
        #back-button:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }
    
        /* Arrange show-info-header elements in a row */
        .show-info-header {
            display: flex;
            align-items: center;
            gap: 20px; /* Space between back button and show info */
            position: relative;
            z-index: 10001; /* Ensure it's above other elements */
        }
    
        /* Optional: Style for show-info div */
        .show-info {
            display: flex;
            flex-direction: column;
        }

        /* Hide Video.js's native spinner when 'hide-videojs-spinner' class is applied */
        .hide-videojs-spinner .vjs-loading-spinner {
            display: none;
        }

        /* Spinner Overlay Styles */
        #spinner {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10001; /* Above ad-container (9999) and other elements (10001, 10002) */
            display: none; /* Hidden by default */
        }

        .spinner {
            border: 5px solid rgba(255, 255, 255, 0.3); /* Light grey with transparency */
            border-top: 5px solid rgb(15, 169, 231); /* Blue border-top */
            border-radius: 50%;
            width: 50px; /* Match Video.js spinner size */
            height: 50px; /* Match Video.js spinner size */
            animation: spin 1s linear infinite; /* Match Video.js spinner animation */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Next Episode Overlay Styles */
        #next-episode-overlay {
            position: absolute;
            bottom: 80px;
            right: 40px;
            width: 250px;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.7), rgba(0, 0, 0, .3));
            padding: 15px;
            border-radius: 10px;
            display: none; /* Hidden by default */
            z-index: 10003; /* Above all other elements */
            color: #fff;
        }

        #next-episode-overlay img {
            width: 100%;
            border-radius: 5px;
            margin-bottom: 10px;
        }

        #next-episode-overlay .next-episode-title {
            font-size: 18px;
            margin-bottom: 5px;
        }

        #next-episode-overlay .countdown {
            font-size: 16px;
        }

        /* Ensure the ad container adapts to fullscreen */
        .video-js.vjs-fullscreen #ad-container {
            width: 100%;
            height: 100%;
            z-index: 9999; /* Ensure ads are above all other elements */
        }
        .fullscreen{
            z-index: 99999;
        }

        #adblock-prompt {
    color: white;
    text-align: center;
    font-size: 24px;
}

#adblock-prompt button {
    margin-top: 20px;
    padding: 10px 20px;
    font-size: 18px;
    cursor: pointer;
}


        /* Custom Fullscreen Button Styles */
        .vjs-custom-fullscreen-button {
            width: 15px;
            height: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .vjs-custom-fullscreen-button i {
            font-size: 15px;
            color: white;
        }

        /* Ad Information Overlay Styles */
        #ad-info-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.6);
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 10004; /* Above other elements */
            display: none; /* Hidden by default */
        }

        #ad-info-overlay .ad-label {
            font-weight: bold;
            margin-right: 10px;
        }

        #ima-countdown {
            display: none !important;
        }

    </style>
</head>
<body>
<div id="video-container">
    <video id="my-video" class="video-js" controls>
        <source src="{{ episode_url }}" type="application/x-mpegURL">
    </video>
    <div id="episode-name" class="episode-name-overlay">
        <div class="show-info-header">
            <button id="back-button" onclick="goBack()" aria-label="Go Back"><i class="bi bi-chevron-left"></i></button>
            <div class="show-info">
                <h1 class="show-title-player">{{ show.name }}</h1>
                <h2 class="episode-title-player">{{ episode.name }}</h2>
            </div>
        </div>
    </div>
    <div id="ad-container"></div>
    <!-- Loading Spinner -->
    <div id="spinner">
        <div class="spinner"></div>
    </div>
    <!-- Next Episode Overlay -->
    <div id="next-episode-overlay">
        <img id="next-episode-thumbnail" src="" alt="Next Episode Thumbnail">
        <div class="next-episode-title" id="next-episode-title">Next Episode: </div>
        <div class="countdown">Play Next Episode in <span id="countdown-timer">15</span>s</div>
    </div>
    <!-- Ad Information Overlay -->
    <div id="ad-info-overlay">
        <span class="ad-label">Ad</span>
        <span class="ad-timer">00:00</span>
    </div>
</div>

<div id="adblock-notification" class="adblock-notification">
    <span>We are supported by ads. Please consider whitelisting this page to support JLTV+</span>
    <button id="close-notification">×</button>
</div>


<!-- IMA SDK Script -->
<script src="https://imasdk.googleapis.com/js/sdkloader/ima3.js"></script>

<!-- Initialize the Player and IMA SDK -->
<script>
    // === Global Variables ===
    const MAX_RETRIES = 1; // Maximum number of ad retries
    let adPlayed = false;
    let player, adContainer, adPlaying, scteMarkers, adsManager, adsLoader, lastPlayedCuePoint;
    let adDisplayContainerInitialized = false;
    let retryCount = 0; // Initialize retry counter
    let adDisplayContainer;
    let adRequestInProgress = false; // Flag to prevent multiple ad requests
    let isPostroll = false;
    let prerollRequested = false;
    let postrollRequested = false;
    let savedTime;
    let sessionId;
    let markersReady = false; // Added to track if markers are ready

    // Initialize adRequestQueue globally
    const adRequestQueue = [];

    // Parse next_episode data from Flask
    const nextEpisode = {{ next_episode | tojson }};
    let countdownInterval;

    // === Separate Markers ===
    let prerollMarker = null;
    let postrollMarker = null;
    let midrollMarkers = [];
    let currentMidrollIndex = 0; // To track the next midroll ad

    // === Utility Functions ===
    function generateSessionId() {
        return Date.now().toString(36) + Math.random().toString(36).substring(2);
    }

    function isMobile() {
        const ua = navigator.userAgent || navigator.vendor || window.opera;
        return /android|iphone|ipad|ipod|opera mini|iemobile|mobile/i.test(ua.toLowerCase());
    }

    function getOS() {
        const userAgent = navigator.userAgent || navigator.vendor || window.opera;
        if (/windows phone/i.test(userAgent)) {
            return "Windows Phone";
        }
        if (/android/i.test(userAgent)) {
            return "Android";
        }
        if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
            return "iOS";
        }
        if (/Win/i.test(userAgent)) {
            return "Windows";
        }
        if (/Mac/i.test(userAgent)) {
            return "MacOS";
        }
        if (/Linux/i.test(userAgent)) {
            return "Linux";
        }
        return "Unknown";
    }

    function getBrowser() {
        const userAgent = navigator.userAgent;
        if (userAgent.indexOf("Firefox") > -1) {
            return "Firefox";
        } else if (userAgent.indexOf("SamsungBrowser") > -1) {
            return "Samsung Internet";
        } else if (userAgent.indexOf("Opera") > -1 || userAgent.indexOf("OPR") > -1) {
            return "Opera";
        } else if (userAgent.indexOf("Trident") > -1) {
            return "Internet Explorer";
        } else if (userAgent.indexOf("Edge") > -1) {
            return "Edge";
        } else if (userAgent.indexOf("Chrome") > -1) {
            return "Chrome";
        } else if (userAgent.indexOf("Safari") > -1) {
            return "Safari";
        }
        return "Unknown";
    }

    const backButton = document.getElementById('back-button');
if (backButton) {
    backButton.addEventListener('mouseenter', showEpisodeName);
    backButton.addEventListener('mouseleave', resetMouseTimer);
}

    function getRandomPublicIP() {
        const firstOctet = Math.floor(Math.random() * (223 - 1)) + 1; // 1-223
        const octets = [
            firstOctet,
            Math.floor(Math.random() * 256),
            Math.floor(Math.random() * 256),
            Math.floor(Math.random() * 256)
        ];
        return octets.join('.');
    }

    async function getCurrentIP(useRandom = true) {
        if (useRandom) {
            return getRandomPublicIP();
        }

        try {
            const response = await fetch('https://api.ipify.org?format=json');
            const data = await response.json();
            return data.ip;
        } catch (error) {
            console.error('Error fetching IP:', error);
            return '0.0.0.0';
        }
    }

    function customEncode(str) {
        return encodeURIComponent(str)
            .replace(/%5B/g, '[')
            .replace(/%5D/g, ']');
    }

    function formatTime(timeInSeconds) {
        const totalSeconds = Math.ceil(timeInSeconds);
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${padZero(minutes)}:${padZero(seconds)}`;
    }

    function padZero(number) {
        return number < 10 ? '0' + number : number;
    }

    // === Spinner Control ===
    function showSpinner() {
        const spinner = document.getElementById('spinner');
        if (spinner) {
            spinner.style.display = 'block';
        }
        const videoPlayer = document.querySelector('.video-js');
        if (videoPlayer) {
            videoPlayer.classList.add('hide-videojs-spinner');
        }
        console.log("Spinner shown");
    }

    function hideSpinner() {
        const spinner = document.getElementById('spinner');
        if (spinner) {
            spinner.style.display = 'none';
        }
        const videoPlayer = document.querySelector('.video-js');
        if (videoPlayer) {
            videoPlayer.classList.remove('hide-videojs-spinner');
        }
        console.log("Spinner hidden");
    }

    // === Episode Name Overlay Control ===
    let mouseTimer;

    function handleMouseMove() {
        showEpisodeName();
        resetMouseTimer();
    }

    function handleMouseEnter() {
        showEpisodeName();
        resetMouseTimer();
    }

    function handleMouseLeave() {
        hideEpisodeName();
        clearTimeout(mouseTimer);
    }

    function resetMouseTimer() {
    clearTimeout(mouseTimer);
    mouseTimer = setTimeout(() => {
        if (!backButton.matches(':hover')) {
            hideEpisodeName();
        }
    }, 2000);
}

    function handleTouch() {
        showEpisodeName();
        resetMouseTimer();
    }

    function showEpisodeName() {
    const episodeNameOverlay = document.getElementById('episode-name');
    if (episodeNameOverlay) {
        episodeNameOverlay.style.opacity = '1';
        clearTimeout(mouseTimer); // Clear any existing timer
    }
}


    function hideEpisodeName() {
        const episodeNameOverlay = document.getElementById('episode-name');
        if (episodeNameOverlay) {
            episodeNameOverlay.style.opacity = '0';
        }
    }

    // === Back Button Function ===
    function goBack() {
    const showId = "{{ show.id }}"; // Assuming you've passed the show ID to the template
    window.location.href = `/show/${showId}`; // Adjust this URL to match your show-detail route
}

    // === Next Episode Overlay Control ===
    let nextEpisodeOverlayShown = false;
    let countdownSeconds = 15; // Starting countdown seconds

    function showNextEpisodeOverlay(timeRemaining) {
    if (nextEpisodeOverlayShown) return;
    nextEpisodeOverlayShown = true;

    const overlay = document.getElementById('next-episode-overlay');
    const thumbnail = document.getElementById('next-episode-thumbnail');
    const title = document.getElementById('next-episode-title');
    const countdown = document.getElementById('countdown-timer');

    if (nextEpisode) {
        thumbnail.src = nextEpisode.thumbnail_url || "{{ url_for('static', filename='images/default_thumbnail.png') }}";
        title.textContent = `Next Episode: ${nextEpisode.name}`;
        countdownSeconds = Math.floor(timeRemaining);

        countdown.textContent = `${countdownSeconds}`;
        overlay.style.display = 'block';
        console.log("Next Episode Overlay displayed");

        countdownInterval = setInterval(() => {
            countdownSeconds = Math.floor(player.duration() - player.currentTime());
            if (countdownSeconds <= 0) {
                clearInterval(countdownInterval);
                playNextEpisode();
            } else {
                countdown.textContent = `${countdownSeconds}`;
            }
        }, 1000);
    } else {
        console.warn("No next episode data available to display overlay");
    }
}


    function playNextEpisode() {
        if (nextEpisode) {
            const nextEpisodeId = nextEpisode.id;
            const showId = "{{ show.id }}";
            const nextPlayUrl = `/play/${nextEpisodeId}/${showId}`;
            console.log(`Redirecting to next episode: ${nextPlayUrl}`);
            window.location.href = nextPlayUrl;
        } else {
            console.warn("No next episode to play");
        }
    }

    // === FullscreenManager Class ===
    class FullscreenManager {
    constructor(videoPlayer, adsManager) {
        this.videoPlayer = videoPlayer;
        this.adsManager = adsManager;

        this.onFullscreenChange = this.onFullscreenChange.bind(this);
        document.addEventListener('fullscreenchange', this.onFullscreenChange);
        document.addEventListener('webkitfullscreenchange', this.onFullscreenChange);
        document.addEventListener('mozfullscreenchange', this.onFullscreenChange);
        document.addEventListener('MSFullscreenChange', this.onFullscreenChange);
    }

    onFullscreenChange() {
        const isFullscreen = !!document.fullscreenElement;
        if (isFullscreen) {
            this.enterFullscreen();
        } else {
            this.exitFullscreen();
        }
    }

    enterFullscreen() {
        const fullscreenWidth = window.innerWidth;
        const fullscreenHeight = window.innerHeight;
        if (this.adsManager && typeof this.adsManager.resize === 'function') {
            this.adsManager.resize(fullscreenWidth, fullscreenHeight, google.ima.ViewMode.FULLSCREEN);
        }
        // Ensure ad container is visible and correctly positioned
        const adContainer = document.getElementById('ad-container');
        if (adContainer) {
            adContainer.style.width = '100%';
            adContainer.style.height = '100%';
            adContainer.style.zIndex = '10000'; // Ensure highest z-index
        }
        console.log("Entered fullscreen.");
    }

    exitFullscreen() {
        const originalWidth = this.videoPlayer.el().offsetWidth;
        const originalHeight = this.videoPlayer.el().offsetHeight;
        if (this.adsManager && typeof this.adsManager.resize === 'function') {
            this.adsManager.resize(originalWidth, originalHeight, google.ima.ViewMode.NORMAL);
        }
        // Reset ad container styles if necessary
        const adContainer = document.getElementById('ad-container');
        if (adContainer) {
            adContainer.style.width = `${originalWidth}px`;
            adContainer.style.height = `${originalHeight}px`;
            adContainer.style.zIndex = '9999'; // Reset z-index
        }
        console.log("Exited fullscreen.");
    }

    destroy() {
        document.removeEventListener('fullscreenchange', this.onFullscreenChange);
        document.removeEventListener('webkitfullscreenchange', this.onFullscreenChange);
        document.removeEventListener('mozfullscreenchange', this.onFullscreenChange);
        document.removeEventListener('MSFullscreenChange', this.onFullscreenChange);
    }
}


    // === IMA SDK Initialization ===
function initIMA(videoElement) {
    if (typeof google === 'undefined' || typeof google.ima === 'undefined') {
        console.error("Google IMA SDK not loaded properly.");
        return;
    }

    adContainer = document.getElementById('ad-container');
    if (!adContainer) {
        console.error("Ad container element not found!");
        return;
    }

    if (!adDisplayContainer) {
        // Pass the actual video element to AdDisplayContainer
        adDisplayContainer = new google.ima.AdDisplayContainer(adContainer, videoElement);
        console.log("AdDisplayContainer instance created with the correct video element.");
    }

    if (!adsLoader) {
        // Create AdsLoader if it hasn't been created yet
        adsLoader = new google.ima.AdsLoader(adDisplayContainer);
        adsLoader.addEventListener(
            google.ima.AdsManagerLoadedEvent.Type.ADS_MANAGER_LOADED,
            onAdsManagerLoaded,
            false);
        adsLoader.addEventListener(
            google.ima.AdErrorEvent.Type.AD_ERROR,
            onAdError,
            false);
        console.log("AdsLoader initialized and event listeners added.");
    }
}


    // === AdsManager Event Handlers ===
    let adTimerInterval;

    function onAdsManagerLoaded(adsManagerLoadedEvent) {
        console.log("AdsManagerLoaded event received.");
        try {
            adsManager = adsManagerLoadedEvent.getAdsManager(player.el());
        } catch (adError) {
            console.error("AdsManager could not be obtained:", adError);
            onAdError();
            return;
        }

        // Add event listeners to AdsManager
        adsManager.addEventListener(google.ima.AdEvent.Type.CONTENT_PAUSE_REQUESTED, onContentPauseRequested);
        adsManager.addEventListener(google.ima.AdEvent.Type.CONTENT_RESUME_REQUESTED, onContentResumeRequested);
        adsManager.addEventListener(google.ima.AdEvent.Type.AD_ERROR, onAdError);
        adsManager.addEventListener(google.ima.AdEvent.Type.ALL_ADS_COMPLETED, onAllAdsCompleted);
        adsManager.addEventListener(google.ima.AdEvent.Type.COMPLETE, onAdEnded);
        adsManager.addEventListener(google.ima.AdEvent.Type.STARTED, onAdStarted);

        try {
            adsManager.init(player.el().offsetWidth, player.el().offsetHeight, google.ima.ViewMode.NORMAL);
            adsManager.start();
            hideSpinner(); // Hide spinner after adsManager starts successfully
            console.log("AdsManager initialized and started successfully.");
        } catch (adError) {
            console.error('AdsManager could not be started:', adError);
            onAdError(); // Handle ad errors
        }
    }

    function onAdStarted(adEvent) {
        const ad = adEvent.getAd();
        if (ad.isLinear()) {
            // Show the ad info overlay
            const adInfoOverlay = document.getElementById('ad-info-overlay');
            if (adInfoOverlay) {
                adInfoOverlay.style.display = 'block';
                const adLabel = adInfoOverlay.querySelector('.ad-label');
                const adTimer = adInfoOverlay.querySelector('.ad-timer');
                adLabel.textContent = 'Ad';
                // Start updating the ad timer
                updateAdTimer();
                adTimerInterval = setInterval(updateAdTimer, 500); // Update every 0.5 seconds
            }
        }
    }

    function updateAdTimer() {
        if (adsManager) {
            const remainingTime = adsManager.getRemainingTime();
            const adInfoOverlay = document.getElementById('ad-info-overlay');
            if (adInfoOverlay) {
                const adTimer = adInfoOverlay.querySelector('.ad-timer');
                adTimer.textContent = formatTime(remainingTime);
            }
        }
    }

    function onAdEnded(adEvent) {
        if (adPlayed) {
            adContainer.style.display = 'none';
        }
        player.el().style.pointerEvents = 'auto';
        player.controls(true);
        hideSpinner(); // Hide spinner when ad ends
        retryCount = 0; // Reset retry count after a successful ad play
        adRequestInProgress = false; // Reset the ad request flag
        console.log("Ad ended successfully");

        // Hide the ad info overlay
        const adInfoOverlay = document.getElementById('ad-info-overlay');
        if (adInfoOverlay) {
            adInfoOverlay.style.display = 'none';
        }
        // Clear the ad timer interval
        if (adTimerInterval) {
            clearInterval(adTimerInterval);
            adTimerInterval = null;
        }
    }

    function onContentPauseRequested() {
        player.pause();
        player.controls(false);
        player.el().style.pointerEvents = 'none';
        adContainer.style.display = 'block'; // Ensure ad container is visible
        adContainer.style.pointerEvents = 'auto'; // Enable pointer events for ads
        adPlaying = true;
        hideSpinner(); // Hide spinner when ad is about to play
        console.log("Content paused for ad");
    }

    function onContentResumeRequested() {
        player.removeClass('vjs-controls-hidden');
        player.muted(false);
        player.controls(true);
        player.el().style.pointerEvents = 'auto';
        adContainer.style.display = 'none'; // Hide ad container after ad
        adContainer.style.pointerEvents = 'none'; // Disable pointer events when not playing ads
        adPlaying = false;
        if (savedTime !== undefined) {
            player.currentTime(savedTime);
            savedTime = undefined;
        }
        player.play();
        hideSpinner(); // Hide spinner when content resumes
        console.log("Content resumed after ad");

        // Hide the ad info overlay
        const adInfoOverlay = document.getElementById('ad-info-overlay');
        if (adInfoOverlay) {
            adInfoOverlay.style.display = 'none';
        }
        // Clear the ad timer interval
        if (adTimerInterval) {
            clearInterval(adTimerInterval);
            adTimerInterval = null;
        }
    }


    function onAdError(adErrorEvent) {
        if (adErrorEvent) {
            console.error('Ad error:', adErrorEvent.getError());
        }

        if (adsManager) {
            adsManager.destroy();
            adsManager = null;
        }

        // Hide the ad info overlay
        const adInfoOverlay = document.getElementById('ad-info-overlay');
        if (adInfoOverlay) {
            adInfoOverlay.style.display = 'none';
        }
        // Clear the ad timer interval
        if (adTimerInterval) {
            clearInterval(adTimerInterval);
            adTimerInterval = null;
        }

         // Add this block to handle Safari ad blocking
        if (!isMobile() && getBrowser() === "Safari") {
            player.ready(function() {
                player.play();
            });
        }

        if (retryCount < MAX_RETRIES) {
            retryCount++;
            console.warn(`Ad failed to load. Retrying (${retryCount}/${MAX_RETRIES})...`);
            // Keep the spinner visible during retries

            adRequestInProgress = false; // Reset the ad request flag to allow retry

            // Implementing a delay before retrying (exponential backoff)
            setTimeout(() => {
                // Determine the ad type to retry
                const adType = prerollRequested && !postrollRequested ? 'preroll' :
                              postrollRequested ? 'postroll' : 'midroll';
                requestAds(adType); // Retry the same ad type
            }, 1000 * retryCount); // 1s, 2s, 3s delays
        } else {
            console.error('Max ad retries reached. Proceeding without ads.');
            adPlaying = false;
            hideSpinner(); // Hide spinner when max retries reached
            retryCount = 0; // Reset retry count
            adRequestInProgress = false; // Reset the ad request flag
            if (isPostroll) {
                console.log("Postroll ad failed to load.");
            } else {
                player.play();
                hideSpinner(); // Ensure spinner is hidden if not already
            }
        }
    }

    function onAllAdsCompleted() {
        adPlaying = false;
        player.removeClass('vjs-controls-hidden');
        player.play();
        hideSpinner(); // Hide spinner when all ads are completed
        retryCount = 0; // Reset retry count after ads complete
        adRequestInProgress = false; // Reset the ad request flag
        console.log("All ads completed successfully");

        // Hide the ad info overlay
        const adInfoOverlay = document.getElementById('ad-info-overlay');
        if (adInfoOverlay) {
            adInfoOverlay.style.display = 'none';
        }
        // Clear the ad timer interval
        if (adTimerInterval) {
            clearInterval(adTimerInterval);
            adTimerInterval = null;
        }
          // Ensure the player starts without user interaction on desktop Safari
   
}
    

    // === Ad Queue Processing ===
    function processAdQueue() {
        while (adRequestQueue.length > 0) {
            const adType = adRequestQueue.shift();
            requestAds(adType);
        }
    }

    // === Request Ads Function ===
    async function requestAds(adType = 'midroll') {
        if (adRequestInProgress) {
            console.warn("Ad request already in progress. Skipping duplicate request.");
            return;
        }

        if (!adDisplayContainerInitialized) {
            console.warn("AdDisplayContainer not initialized yet");
            return;
        }

        adRequestInProgress = true; // Set the flag to indicate ad request is in progress
        console.log(`Starting ${adType} ad request`);

        const timestamp = Date.now();
        const cacheBuster = `${timestamp}${Math.random().toString(36).substring(2)}`;

        const currentIP = await getCurrentIP(false); // Use actual IP instead of random

        // Gather additional dynamic data
        const episodeName = "{{ episode.name }}";
        const showName = "{{ show.name }}";
        const episodeId = "{{ episode.id }}"; // Assuming you have an episode ID
        const showId = "{{ show.id }}"; // Assuming you have a show ID
        const referrer = document.referrer || 'direct';
        const pageURL = window.location.href;
        const contentGenre = "{{ episode.category }}"; // Assuming category is available
        const userAgent = navigator.userAgent;
        const language = navigator.language || 'en';

        // Device Information
        const screenWidth = window.screen.width;
        const screenHeight = window.screen.height;
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const deviceType = isMobile() ? 'mobile' : 'desktop';
        const os = getOS(); // Function to determine OS
        const browser = getBrowser(); // Function to determine browser
        const sitePage = window.location.href;
        // Content Length in seconds
        const contentLength = Math.floor(player.duration()) || 0;

        // Define the parameters in order
        const parameters = [
            { name: 'site_id', placeholder: '50488', value: '50488' },
            { name: 'site_page', placeholder: '[SITE_PAGE]', value: sitePage },
            { name: 'format', placeholder: 'vast', value: 'vast' },
            { name: 'pod_duration', placeholder: '[POD_DURATION]', value: '60' },
            { name: 'cb', placeholder: '[CACHEBUSTER]', value: cacheBuster },
            { name: 'ip', placeholder: '[IP]', value: currentIP },
            { name: 'ua', placeholder: '[UA]', value: undefined },
            { name: 'player_height', placeholder: '[HEIGHT]', value: player.el().offsetHeight },
            { name: 'player_width', placeholder: '[WIDTH]', value: player.el().offsetWidth },
            { name: 'is_lat', placeholder: '[LIMITED_AD_TRACKING]', value: '0' },
            { name: 'site_name', placeholder: '[CHANNEL_NAME]', value: 'JLTV' },
            { name: 'content_cat', placeholder: '[CONTENT_CAT]', value: contentGenre },
            { name: 'content_channel', placeholder: '[CONTENT_CHANNEL]', value: undefined },
            { name: 'content_context', placeholder: '[CONTENT_CONTEXT]', value: undefined },
            { name: 'content_dist_id', placeholder: '[CONTENT_DIST_ID]', value: undefined },
            { name: 'content_dist_name', placeholder: '[CONTENT_DIST_NAME]', value: undefined },
            { name: 'content_episode', placeholder: '[CONTENT_EPISODE]', value: undefined },
            { name: 'content_genre', placeholder: '[CONTENT_GENRE]', value: contentGenre },
            { name: 'content_id', placeholder: '[CONTENT_ID]', value: episodeId },
            { name: 'content_keywords', placeholder: '[CONTENT_KEYWORDS]', value: "{{ episode.keywords }}" },
            { name: 'content_language', placeholder: '[CONTENT_LANGUAGE]', value: language },
            { name: 'content_length', placeholder: '[CONTENT_LENGTH]', value: contentLength },
            { name: 'content_network', placeholder: '[CONTENT_NETWORK]', value: undefined },
            { name: 'content_prodqual', placeholder: '[CONTENT_PROD]', value: undefined },
            { name: 'content_producer_id', placeholder: '[CONTENT_PRODUCER_ID]', value: undefined },
            { name: 'content_producer', placeholder: '[CONTENT_PRODUCER_NAME]', value: undefined },
            { name: 'content_rating', placeholder: '[CONTENT_RATING]', value: undefined },
            { name: 'content_season', placeholder: '[CONTENT_SEASON]', value: "{{ episode.season.number }}" },
            { name: 'content_series', placeholder: '[CONTENT_SERIES]', value: showName },
            { name: 'content_title', placeholder: '[CONTENT_TITLE]', value: episodeName },
            { name: 'content_url', placeholder: '[CONTENT_URL]', value: sitePage },
            { name: 'buyeruid', placeholder: '[BUYERUID]', value: undefined },
            { name: 'us_privacy', placeholder: '[US_PRIVACY]', value: undefined },
            { name: 'consent', placeholder: '[CONSENT]', value: undefined },
            { name: 'coppa', placeholder: '[COPPA]', value: undefined },
            { name: 'custom_5', placeholder: '[CUSTOM_5]', value: undefined },
            { name: 'custom_6', placeholder: '[CUSTOM_6]', value: undefined },
            { name: 'custom_7', placeholder: '[CUSTOM_7]', value: undefined },
            { name: 'custom_8', placeholder: '[CUSTOM_8]', value: undefined },
            { name: 'custom_9', placeholder: '[CUSTOM_9]', value: undefined },
            { name: 'custom_10', placeholder: '[CUSTOM_10]', value: undefined },
            { name: 'custom_11', placeholder: '[CUSTOM_11]', value: undefined },
            { name: 'custom_12', placeholder: '[CUSTOM_12]', value: undefined },
            { name: 'custom_13', placeholder: '[CUSTOM_13]', value: undefined },
            { name: 'custom_14', placeholder: '[CUSTOM_14]', value: undefined },
            { name: 'custom_15', placeholder: '[CUSTOM_15]', value: undefined },
            { name: 'custom_16', placeholder: '[CUSTOM_16]', value: undefined },
            { name: 'custom_17', placeholder: '[CUSTOM_17]', value: undefined },
            { name: 'custom_18', placeholder: '[CUSTOM_18]', value: undefined },
            { name: 'device_language', placeholder: '[DEVICE_LANGUAGE]', value: language },
            { name: 'lat', placeholder: '[LAT]', value: undefined },
            { name: 'lon', placeholder: '[LON]', value: undefined },
            { name: 'device_type', placeholder: '[DEVICE_TYPE]', value: deviceType },
            { name: 'gdpr', placeholder: '[GDPR]', value: undefined },
            { name: 'gender', placeholder: '[GENDER]', value: 'male' },
            { name: 'genre_id', placeholder: '[GENRE_ID]', value: undefined },
            { name: 'ifa_type', placeholder: '[IFA_TYPE]', value: undefined },
            { name: 'iris_context', placeholder: '[IRIS_CONTEXT]', value: undefined },
            { name: 'iris_id', placeholder: '[IRIS_ID]', value: undefined },
            { name: 'livestream', placeholder: '[LIVESTREAM]', value: undefined },
            { name: 'max_bitrate', placeholder: '[MAXBITRATE]', value: undefined },
            { name: 'min_bitrate', placeholder: '[MINBITRATE]', value: undefined },
            { name: 'partner_domain', placeholder: '[PARTNER_DOMAIN]', value: undefined },
            { name: 'position', placeholder: '[POSITION]', value: undefined },
            { name: 'preferred_language', placeholder: '[PREFERRED_LANGUAGE]', value: 'en' },
            { name: 'rights_holder', placeholder: '[RIGHTS_HOLDER]', value: undefined },
            { name: 'ssai_enabled', placeholder: '[SSAI_ENABLED]', value: undefined },
            { name: 'ssai_vendor', placeholder: '[SSAI_VENDOR]', value: undefined },
            { name: 'session_id', placeholder: '[SESSION_ID]', value: sessionId },
            { name: 'schain', placeholder: '[SCHAIN]', value: undefined },
            { name: 'yob', placeholder: '[YOB]', value: undefined },
        ];

        // Adjust parameters based on adType
        if (adType === 'preroll') {
            parameters.push({ name: 'ad_position', value: 'preroll' });
        } else if (adType === 'postroll') {
            parameters.push({ name: 'ad_position', value: 'postroll' });
        } else {
            parameters.push({ name: 'ad_position', value: 'midroll' });
        }

        // Build the VAST URL
        let vastUrl = 'https://obs.ads.ottera.tv/v1/s2s-hb?';

        // Build the query string with custom encoding
        const queryParams = parameters.map(param => {
            const value = (param.value !== undefined && param.value !== null) ? param.value : param.placeholder;
            const encodedName = encodeURIComponent(param.name);
            const encodedValue = customEncode(value);
            return `${encodedName}=${encodedValue}`;
        });

        vastUrl += queryParams.join('&');

        console.log("VAST URL:", vastUrl); // For debugging purposes

        // Configure the AdsRequest
        const adsRequest = new google.ima.AdsRequest();
        adsRequest.adTagUrl = vastUrl;
        adsRequest.omitUiElements = ['countdown']; // Disable the countdown UI element

        // Set ad slot sizes
        adsRequest.linearAdSlotWidth = player.el().offsetWidth;
        adsRequest.linearAdSlotHeight = player.el().offsetHeight;
        adsRequest.nonLinearAdSlotWidth = player.el().offsetWidth;
        adsRequest.nonLinearAdSlotHeight = player.el().offsetHeight;

        // Make the ad request
        try {
            adsLoader.requestAds(adsRequest);
            console.log("Ads requested");
        } catch (error) {
            console.error("Error requesting ads:", error);
            hideSpinner(); // Hide spinner on failure
            adRequestInProgress = false;
        }
    }

    // === Initialize the Player ===
    let fullscreenManager; // Declare globally to manage its lifecycle

    function initializePlayer() {
    console.log("Initializing Video.js player...");
    // Dispose of existing player and ads if any
    disposePlayer();
    destroyAds();

    const isMobileDevice = isMobile(); // Correctly detect mobile devices
    const isDesktopSafari = !isMobileDevice && getBrowser() === "Safari";

    player = videojs('my-video', {
        autoplay: isDesktopSafari ? false : (isMobileDevice ? false : true), // Autoplay based on device
        muted: isMobileDevice ? true : false,    // Ensure muted for autoplay compliance
        controls: true,
        playsinline: true,
        controlBar: {
            fullscreenToggle: false, // Disable the default fullscreen button
            // You can specify other control bar components here if needed
        },
        fullscreen: {
            enabled: false // Disable the default fullscreen handling
        }
    });

    adContainer = document.getElementById('ad-container');
    if (adContainer) {
        adContainer.style.display = 'none';
    } else {
        console.error("Ad container element not found!");
    }
    window.addEventListener("load", hideAddressBar);
    window.addEventListener("orientationchange", hideAddressBar);
    adPlaying = false;
    adPlayed = false;
    scteMarkers = {{ scte_markers|safe }};
    lastPlayedCuePoint = -1;
    sessionId = generateSessionId();
    adRequestQueue.length = 0;
    prerollRequested = false;
    postrollRequested = false;
    savedTime = undefined;
    retryCount = 0;
    adRequestInProgress = false; // Reset the ad request flag
    markersReady = false;

    midrollMarkers = []; // Reset midrollMarkers
    prerollMarker = null; // Reset prerollMarker
    postrollMarker = null; // Reset postrollMarker

    // === Separate Markers into Preroll, Midroll, and Postroll ===
    scteMarkers.sort((a, b) => a.time - b.time);
    console.log("SCTE Markers sorted:", scteMarkers);

    scteMarkers.forEach(marker => {
        if (marker.time === 0) {
            prerollMarker = marker;
            console.log(`Preroll marker identified at ${marker.time} seconds.`);
        } else if (marker.time >= player.duration() - 0.5) {
            postrollMarker = marker;
            console.log(`Postroll marker identified at ${marker.time} seconds.`);
        } else {
            midrollMarkers.push(marker);
            console.log(`Midroll marker detected at time=${marker.time} seconds.`);
        }
    });

    // Sort midrollMarkers ascending
    midrollMarkers.sort((a, b) => a.time - b.time);
    console.log("Midroll Markers sorted:", midrollMarkers);

    player.on('timeupdate', handleTimeUpdate);
    player.on('seeking', handleSeeking);

    const episodeNameOverlay = document.getElementById('episode-name');
    const episodeNameH2 = episodeNameOverlay ? episodeNameOverlay.querySelector('h2') : null;
    if (episodeNameH2) {
        episodeNameH2.textContent = "{{ episode.name }}";
    }

    player.on('loadedmetadata', function() {
        console.log("Video metadata loaded.");
        markersReady = true; // Mark that markers are ready
    });

    player.on('play', function() {
        console.log("Play event triggered.");

        // Initialize IMA SDK only once
        if (!adDisplayContainerInitialized) {
            const videoElement = player.el().getElementsByTagName('video')[0];
            if (videoElement) {
                initIMA(videoElement);
                adDisplayContainer.initialize();
                adDisplayContainerInitialized = true;
                console.log("AdDisplayContainer initialized on user interaction.");
            } else {
                console.error("Actual video element not found for IMA SDK initialization.");
                return;
            }
        }

        if (prerollMarker && !prerollRequested) {
            console.log("Preroll ad is set to play.");
            prerollRequested = true;
            adPlaying = true;
            player.pause();
            showSpinner(); // Show spinner when requesting preroll ads
            console.log("Requesting preroll ads...");
            // Introduce a slight delay to ensure AdDisplayContainer is fully initialized
            setTimeout(() => {
                requestAds('preroll');
            }, 100); // 100ms delay
        } else if (!adPlaying) {
            // If no preroll or ad blocker detected, continue playing
            player.play();
        }

        if (adPlaying) {
            player.pause();
        }
        showEpisodeName();
        setTimeout(hideEpisodeName, 3000);
    });

    player.on('pause', hideEpisodeName);
    player.on('ended', function() {
        console.log("Video ended.");
         clearInterval(countdownInterval); // Clear the countdown interval
        if (postrollMarker && !postrollRequested) {
            console.log("Postroll ad is set to play.");
            postrollRequested = true;
            adPlaying = true;
            showSpinner(); // Show spinner when requesting postroll ads
            requestAds('postroll');
            console.log("Requesting postroll ads...");
        } else {
            if (adsLoader) {
                adsLoader.contentComplete();
            }
        }
    });

    // Mouse and Touch Events
    player.el().addEventListener('mousemove', handleMouseMove);
    player.el().addEventListener('mouseenter', handleMouseEnter);
    player.el().addEventListener('mouseleave', handleMouseLeave);
    player.el().addEventListener('touchstart', handleTouch);
    player.el().addEventListener('touchmove', handleTouch);
    player.el().addEventListener('touchend', handleTouch);

    // === Custom Fullscreen Button ===

    // Define the custom fullscreen button
    const Button = videojs.getComponent('Button');

    const CustomFullscreenToggle = videojs.extend(Button, {
        constructor: function() {
            Button.apply(this, arguments);
            this.addClass('vjs-custom-fullscreen-button');
            this.controlText('Fullscreen');
            this.el().innerHTML = '<i class="bi bi-fullscreen"></i>'; // Initial icon
        },
        handleClick: function() {
            const videoContainer = document.getElementById('video-container');
            if (!document.fullscreenElement) {
                if (videoContainer.requestFullscreen) {
                    videoContainer.requestFullscreen();
                } else if (videoContainer.webkitRequestFullscreen) { /* Safari */
                    videoContainer.webkitRequestFullscreen();
                } else if (videoContainer.msRequestFullscreen) { /* IE11 */
                    videoContainer.msRequestFullscreen();
                }
                this.el().innerHTML = '<i class="bi bi-fullscreen-exit"></i>'; // Change to exit icon
                this.addClass('fullscreen-active');
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { /* Safari */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE11 */
                    document.msExitFullscreen();
                }
                this.el().innerHTML = '<i class="bi bi-fullscreen"></i>'; // Change to fullscreen icon
                this.removeClass('fullscreen-active');
            }
        }
    });

    // Register the new component
    videojs.registerComponent('CustomFullscreenToggle', CustomFullscreenToggle);

    // Add the custom button to the control bar
    player.ready(function() {
        const customFullscreenToggle = player.controlBar.addChild('CustomFullscreenToggle', {});
        // Position the custom fullscreen button at the end of the control bar
        player.controlBar.el().appendChild(customFullscreenToggle.el());
    });

    // Initialize FullscreenManager
    fullscreenManager = new FullscreenManager(player, adsManager);

    // === Window Resize Event to Resize AdsManager ===
    window.addEventListener('resize', function() {
        if (adsManager) {
            const isFullscreen = !!document.fullscreenElement;

            if (isFullscreen) {
                adsManager.resize(window.innerWidth, window.innerHeight, google.ima.ViewMode.FULLSCREEN);
            } else {
                adsManager.resize(player.el().offsetWidth, player.el().offsetHeight, google.ima.ViewMode.NORMAL);
            }
            console.log("AdsManager resized on window resize.");
        }
    });

    console.log("Player initialized.");
}



    // === Function to Dispose of the Player ===
    function disposePlayer() {
        if (player) {
            console.log("Disposing existing Video.js player.");
            // Remove event listeners to prevent duplication
            player.off('timeupdate', handleTimeUpdate);
            player.off('seeking', handleSeeking);
            player.off('play');
            player.off('pause');
            player.off('ended');

            player.el().removeEventListener('mousemove', handleMouseMove);
            player.el().removeEventListener('mouseenter', handleMouseEnter);
            player.el().removeEventListener('mouseleave', handleMouseLeave);
            player.el().removeEventListener('touchstart', handleTouch);
            player.el().removeEventListener('touchmove', handleTouch);
            player.el().removeEventListener('touchend', handleTouch);

            // Destroy FullscreenManager
            if (fullscreenManager) {
                fullscreenManager.destroy();
                fullscreenManager = null;
            }

            // Remove custom fullscreen button
            const customButton = player.controlBar.getChild('CustomFullscreenToggle');
            if (customButton) {
                player.controlBar.removeChild(customButton);
            }

            player.dispose();
            player = null;
            console.log("Player disposed.");
        }
    }

    // === Function to Destroy AdsManager ===
    function destroyAds() {
        if (adsManager) {
            console.log("Destroying AdsManager.");
            adsManager.destroy();
            adsManager = null;
            console.log("AdsManager destroyed.");
        }
    }

    // === Before Unload Event to Cleanup ===
    window.addEventListener('beforeunload', function() {
        console.log("Page is unloading. Cleaning up.");
        adRequestQueue.length = 0;
        lastPlayedCuePoint = -1;
        sessionId = generateSessionId();

        // Dispose player and ads to clean up
        disposePlayer();
        destroyAds();
        console.log("Player and ads disposed on page unload.");
    });

    class AdblockDetector {
    bannerIds;

    constructor() {
        this.bannerIds = [
            'AdHeader',
            'AdContainer',
            'AD_Top',
            'homead',
            'ad-lead'
        ];
        this.init();
    }

    init() {
        const dataContainer = document.createElement('div');
        dataContainer.innerHTML = this.generatesBannersString();
        document.body.appendChild(dataContainer);
    }

    detect() {
        return !this.bannerIds.every(bannerId => this.checkVisibility(bannerId));
    }

    generatesBannersString() {
        return this.bannerIds
            .map(bannerId => `<div id="${bannerId}"></div>`)
            .join('');
    }

    checkVisibility(bannerId) {
        const el = document.querySelector(`#${bannerId}`);
        if (el) return el.offsetParent;
        return null;
    }
}

      // === Ad Blocker Detection ===
      function detectAdBlocker() {
    const detector = new AdblockDetector();
    if (detector.detect()) {
        console.log("Ad blocker detected.");
        handleAdBlockerDetected();
    } else {
        console.log("No ad blocker detected.");
    }
}


function handleAdBlockerDetected() {
    const notification = document.getElementById('adblock-notification');
    notification.style.display = 'block';
    
    // Automatically fade away after 5 seconds
    setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => {
            notification.style.display = 'none';
            notification.style.opacity = '1';
        }, 500);
    }, 5000);

    // Close button functionality
    document.getElementById('close-notification').addEventListener('click', () => {
        notification.style.display = 'none';
    });
}

// Modify the existing detectAdBlocker function
function detectAdBlocker() {
    const detector = new AdblockDetector();
    if (detector.detect()) {
        console.log("Ad blocker detected.");
        handleAdBlockerDetected();
    } else {
        console.log("No ad blocker detected.");
    }
}
       
        

    // === Initialize the Player and IMA SDK ===
    document.addEventListener('DOMContentLoaded', function() {
        initializePlayer(); // Initialize the player first
        initIMA();  
        detectAdBlocker();        // Then initialize the IMA SDK
    });

    // === Function to Handle Time Updates for Midroll Ads and Next Episode Overlay ===
    function handleTimeUpdate() {
        if (adPlaying) {
            return;
        }

        // Ensure markers are ready
        if (!markersReady) {
            console.log("Markers not ready yet. Skipping ad handling.");
            return;
        }

        const currentTime = player.currentTime();
        const duration = player.duration();
        const timeRemaining = duration - currentTime;
        const bufferTime = 15; // seconds before the end to show the overlay

        console.log(`Time Update - Current Time: ${currentTime}, Duration: ${duration}, Buffer Time: ${bufferTime}`);

        // Ensure duration is valid and greater than bufferTime
        if (timeRemaining <= bufferTime && !nextEpisodeOverlayShown && nextEpisode) {
        showNextEpisodeOverlay(timeRemaining);
    }

        // Trigger midroll ads sequentially
        if (currentMidrollIndex < midrollMarkers.length) {
            const nextMidrollMarker = midrollMarkers[currentMidrollIndex];
            if (currentTime >= nextMidrollMarker.time && !adPlaying) {
                adPlaying = true;
                player.pause();
                showSpinner(); // Show spinner when requesting mid-roll ads
                console.log(`Mid-roll ad triggered at ${nextMidrollMarker.time} seconds.`);
                requestAds('midroll');
                currentMidrollIndex++;
            }
        }
    }

    // === Function to Handle Seeking for Ads ===
    function handleSeeking() {
        const currentTime = player.currentTime();
        const bufferTime = 0.5;

        // Find the first midroll marker after the current time
        const newIndex = midrollMarkers.findIndex(marker => marker.time > currentTime);
        lastPlayedCuePoint = newIndex - 1;
        lastPlayedCuePoint = Math.max(-1, Math.min(lastPlayedCuePoint, midrollMarkers.length - 1));

        const nextCuePoint = midrollMarkers[lastPlayedCuePoint + 1];
        if (nextCuePoint && currentTime >= nextCuePoint.time - bufferTime && !adPlaying) {
            player.pause();
            adPlaying = true;
            savedTime = currentTime;
            showSpinner(); // Show spinner when requesting ads due to seeking
            console.log(`Seeking triggered ad request at ${currentTime} seconds.`);
            requestAds('midroll');
            currentMidrollIndex = lastPlayedCuePoint + 2; // Move to the next marker
        }
    }

    let controlsTimeout;

    function showControls() {
        player.addClass('vjs-user-active');
        clearTimeout(controlsTimeout);
        controlsTimeout = setTimeout(hideControls, 3000); // Hide after 3 seconds of inactivity
    }

    function hideControls() {
        player.removeClass('vjs-user-active');
    }

    player.on('mousemove', showControls);
    player.on('touchstart', showControls);
    player.on('click', showControls);

    function hideAddressBar() {
        if (document.documentElement.scrollHeight > window.outerHeight + 10) {
            setTimeout(function() {
                window.scrollTo(0, 1);
            }, 0);
        } else {
            setTimeout(function() {
                window.scrollTo(0, 1);
            }, 0);
        }
    }
</script>
</body>
</html>
